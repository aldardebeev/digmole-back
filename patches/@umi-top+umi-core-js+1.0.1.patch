diff --git a/node_modules/@umi-top/umi-core-js/lib/index.js b/node_modules/@umi-top/umi-core-js/lib/index.js
index ae8a386..70685c1 100644
--- a/node_modules/@umi-top/umi-core-js/lib/index.js
+++ b/node_modules/@umi-top/umi-core-js/lib/index.js
@@ -960,7 +960,7 @@ function bech32Encode (bytes) {
  * @private
  */
 function bech32Decode (bech32) {
-  if (bech32.length !== 62 && bech32.length !== 66) {
+  if (bech32.length !== 62 && bech32.length !== 66  && bech32.length !== 64) {
     throw new Error('bech32: invalid length')
   }
   const str = bech32.toLowerCase()
@@ -1122,15 +1122,22 @@ function checkAlphabet (chars) {
  */
 function versionToPrefix (version) {
   validateInt(version, 0, 65535)
+
   if (version === 0) {
     return 'genesis'
   }
+  
   if ((version & 0x8000) === 0x8000) {
-    throw new Error('bech32: invalid version')
+    const a = (version & 0x03E0) >> 5
+    const b = (version & 0x001F)
+
+    return "rod" + String.fromCharCode((a + 47), (b + 47))
   }
+
   const a = (version & 0x7C00) >> 10
   const b = (version & 0x03E0) >> 5
   const c = (version & 0x001F)
+
   checkPrefixChars([a, b, c])
   return String.fromCharCode((a + 96), (b + 96), (c + 96))
 }
@@ -1145,13 +1152,22 @@ function prefixToVersion (prefix) {
   if (prefix === 'genesis') {
     return 0
   }
-  validateStr(prefix, 3)
-  const a = prefix.charCodeAt(0) - 96
-  const b = prefix.charCodeAt(1) - 96
-  const c = prefix.charCodeAt(2) - 96
-  checkPrefixChars([a, b, c])
-  return (a << 10) + (b << 5) + c
+
+  if (prefix.length !== 3 && prefix.length !== 5) throw new Error('invalid length')
+
+  let toCheck = []
+
+  for (let i = 0; i <= prefix.length - 1; i++) {
+    const modifier = /\d+/.test(prefix[i]) ? 47 : 96
+
+    toCheck.push(prefix.charCodeAt(i) - modifier)
+  }
+
+  checkPrefixChars(toCheck)
+
+  return toCheck.length > 3 ? 32768 + ((toCheck[3] << 5) + toCheck[4]) : (toCheck[0] << 10) + (toCheck[1] << 5) + toCheck[2]
 }
+
 /**
  * @param {number[]} chars
  * @throws {Error}
diff --git a/node_modules/@umi-top/umi-core-js/lib/index.js.flow b/node_modules/@umi-top/umi-core-js/lib/index.js.flow
deleted file mode 100644
index 88b58a9..0000000
--- a/node_modules/@umi-top/umi-core-js/lib/index.js.flow
+++ /dev/null
@@ -1,76 +0,0 @@
-/**
- * Flowtype definitions for index
- * Generated by Flowgen from a Typescript Definition
- * Flowgen v1.11.0
- * @flow
- */
-
-declare export class Address {
-  constructor(): this;
-  static fromBech32(bech32: string): Address;
-  static fromBytes(bytes: ArrayLike<number>): Address;
-  static fromKey(key: PublicKey | SecretKey): Address;
-  getBech32(): string;
-  getBytes(): number[];
-  getPrefix(): string;
-  setPrefix(prefix: string): Address;
-  getPublicKey(): PublicKey;
-  setPublicKey(publicKey: PublicKey): Address;
-}
-declare export class PublicKey {
-  constructor(bytes: ArrayLike<number>): this;
-  getBytes(): number[];
-  verifySignature(
-    signature: ArrayLike<number>,
-    message: ArrayLike<number>
-  ): boolean;
-}
-declare export class SecretKey {
-  constructor(bytes: ArrayLike<number>): this;
-  static fromSeed(seed: ArrayLike<number>): SecretKey;
-  getBytes(): number[];
-  getPublicKey(): PublicKey;
-  sign(message: ArrayLike<number>): number[];
-}
-declare export class Transaction {
-  static Genesis: number;
-  static Basic: number;
-  static CreateStructure: number;
-  static UpdateStructure: number;
-  static UpdateProfitAddress: number;
-  static UpdateFeeAddress: number;
-  static CreateTransitAddress: number;
-  static DeleteTransitAddress: number;
-  constructor(): this;
-  static fromBytes(bytes: ArrayLike<number>): Transaction;
-  getBytes(): number[];
-  getHash(): number[];
-  getVersion(): number;
-  setVersion(version: number): Transaction;
-  getSender(): Address;
-  setSender(address: Address): Transaction;
-  getRecipient(): Address;
-  setRecipient(address: Address): Transaction;
-  getValue(): number;
-  setValue(value: number): Transaction;
-  getNonce(): number;
-  setNonce(nonce: number): Transaction;
-  getSignature(): number[];
-  setSignature(signature: ArrayLike<number>): Transaction;
-  sign(secretKey: SecretKey): Transaction;
-  getPrefix(): string;
-  setPrefix(prefix: string): Transaction;
-  getName(): string;
-  setName(name: string): Transaction;
-  getProfitPercent(): number;
-  setProfitPercent(percent: number): Transaction;
-  getFeePercent(): number;
-  setFeePercent(percent: number): Transaction;
-  verify(): boolean;
-}
-declare export function base64Decode(base64: string): number[];
-declare export function base64Encode(bytes: number[]): string;
-declare export function hexDecode(hex: string): number[];
-declare export function hexEncode(bytes: number[]): string;
-declare export function textDecode(bytes: number[]): string;
-declare export function textEncode(text: string): number[];
diff --git a/node_modules/@umi-top/umi-core-js/lib/index.min.js b/node_modules/@umi-top/umi-core-js/lib/index.min.js
deleted file mode 100644
index 9827e93..0000000
--- a/node_modules/@umi-top/umi-core-js/lib/index.min.js
+++ /dev/null
@@ -1,6 +0,0 @@
-/**
- * @license
- * Copyright (c) 2020 UMI
- * MIT Licensed
- */
-var umi=function(t){"use strict";var r=function(){function t(){this._bytes=o(34),this.setPrefix("umi")}return t.fromBech32=function(r){var e=new t;return h(e._bytes,function(t){if(62!==t.length&&66!==t.length)throw new Error("bech32: invalid length");var r=t.toLowerCase(),e=r.lastIndexOf("1");if(-1===e)throw new Error("bech32: missing separator");var n=r.slice(0,e),i=y(n),f=r.slice(e+1);return function(t){for(var r=0,e=t.length;r<e;r++)if(-1===u.indexOf(t.charAt(r)))throw new Error("bech32: invalid character")}(f),function(t,r){var e=l(t),n=g(r),i=o(e.length+n.length);if(h(i,e),h(i,n,e.length),1!==a(i))throw new Error("bech32: invalid checksum")}(n,f),c(w(i),function(t){for(var r=0,e=0,n=g(t),i=[],o=0;o<n.length;o++)for(r=r<<5|n[o],e+=5;e>=8;)e-=8,i[i.length]=r>>e&255;if(e>=5||r<<8-e&255)throw new Error("bech32: invalid data");return i}(f.slice(0,-6)))}(r)),e},t.fromBytes=function(r){if(34!==r.length)throw new Error("length must be 34 bytes");var e=new t;return h(e._bytes,r),e},t.fromKey=function(r){return(new t).setPublicKey(r.getPublicKey())},t.prototype.getBech32=function(){return t=this._bytes,r=v((t[0]<<8)+t[1]),e=function(t){for(var r=0,e=0,n="",i=0;i<t.length;i++)for(r=r<<8|t[i],e+=8;e>=5;)n+=u.charAt(r>>(e-=5)&31);return e>0&&(n+=u.charAt(r<<5-e&31)),n}(t.slice(2)),n=function(t,r){var e=g(r),n=l(t),i=o(n.length+e.length+6);h(i,n),h(i,e,n.length);for(var f=1^a(i),c="",s=0;s<6;s++)c+=u.charAt(f>>5*(5-s)&31);return c}(r,e),r+"1"+e+n;var t,r,e,n},t.prototype.getBytes=function(){return this._bytes.slice(0)},t.prototype.getPrefix=function(){return v(_(this._bytes.slice(0,2)))},t.prototype.setPrefix=function(t){return h(this._bytes,w(y(t))),this},t.prototype.getPublicKey=function(){return new e(this._bytes.slice(2))},t.prototype.setPublicKey=function(t){return h(this._bytes,t.getBytes(),2),this},t}(),e=function(){function t(t){if(this._bytes=[],32!==t.length)throw new Error("invalid length");h(this._bytes,t)}return t.prototype.getBytes=function(){return this._bytes.slice(0)},t.prototype.getPublicKey=function(){return this},t.prototype.verifySignature=function(t,r){if(64!==t.length)throw new Error("invalid length");return function(t,r,e){var n=[],i=[],o=[[],[],[],[]],c=[[],[],[],[]];if(!function(t,r){var e=[],n=[],i=[],o=[],f=[],c=[],s=[];h(t[2],E),function(t,r){for(var e=0;e<16;e++)t[e]=r[2*e]+(r[2*e+1]<<8);t[15]&=32767}(t[1],r),D(i,t[1],t[1]),D(o,i,j),N(i,i,t[2]),K(o,t[2],o),D(f,o,o),D(c,f,f),D(s,c,f),D(e,s,i),D(e,e,o),function(t,r){var e,n=[];for(e=0;e<16;e++)n[e]=r[e];for(e=250;e>=0;e--)D(n,n,n),1!==e&&D(n,n,r);for(e=0;e<16;e++)t[e]=n[e]}(e,e),D(e,e,i),D(e,e,o),D(e,e,o),D(t[0],e,o),D(n,t[0],t[0]),D(n,n,o),G(n,i)||D(t[0],t[0],q);if(D(n,t[0],t[0]),D(n,n,o),!G(n,i))return!1;L(t[0])===r[31]>>7&&N(t[0],A,t[0]);return D(t[3],t[0],t[1]),!0}(c,f(e)))return!1;h(n,t,0),h(n,r,64);var s=n.slice(0);h(s,e,32);var u=Y(s);return V(u),k(o,c,u),T(c,n.slice(32)),O(o,c),U(i,o),z(n,i)}(t,r,this._bytes)},t}(),n=function(){function t(t){if(this._bytes=[],64!==t.length)throw new Error("invalid length");h(this._bytes,t)}return t.fromSeed=function(r){var e=r;return 32!==r.length&&(e=J(e)),new t(function(t){var r=[],e=[[],[],[],[]],n=Y(t);return n[0]&=248,n[31]&=127,n[31]|=64,T(e,n),U(r,e),c(t,r)}(e))},t.prototype.getBytes=function(){return this._bytes.slice(0)},t.prototype.getPublicKey=function(){return new e(this._bytes.slice(32,64))},t.prototype.sign=function(t){return function(t,r){var e=Y(f(r,0,32));e[0]&=248,e[31]&=127,e[31]|=64;var n=e.slice(0);h(n,t,64);var i=Y(n.slice(32));V(i);var o=[[],[],[],[]];T(o,i),U(n,o),h(n,f(r,32),32);var s=Y(n);V(s);for(var u=0;u<32;u++)for(var a=0;a<32;a++)i[u+a]+=s[u]*e[a];return c(n.slice(0,32),S(n.slice(32),i).slice(0,32))}(t,this._bytes)},t}(),i=function(){function t(){this._bytes=o(150),this.setVersion(t.Basic)}return t.fromBytes=function(r){if(150!==r.length)throw new Error("invalid length");var e=new t;return h(e._bytes,r),e},t.prototype.getBytes=function(){return this._bytes.slice(0)},t.prototype.getHash=function(){return J(this._bytes)},t.prototype.getVersion=function(){return this._bytes[0]},t.prototype.setVersion=function(t){return ct(t,0,7),this._bytes[0]=t,this},t.prototype.getSender=function(){return r.fromBytes(this._bytes.slice(1,35))},t.prototype.setSender=function(t){return h(this._bytes,t.getBytes(),1,34),this},t.prototype.getRecipient=function(){return this.checkVersion([0,1,4,5,6,7]),r.fromBytes(this._bytes.slice(35,69))},t.prototype.setRecipient=function(t){return this.checkVersion([0,1,4,5,6,7]),h(this._bytes,t.getBytes(),35),this},t.prototype.getValue=function(){return this.checkVersion([0,1]),d(this._bytes.slice(69,77))},t.prototype.setValue=function(t){return this.checkVersion([0,1]),ct(t,1,0x10000000000000000),h(this._bytes,b(t),69),this},t.prototype.getNonce=function(){return d(this._bytes.slice(77,85))},t.prototype.setNonce=function(t){return ct(t,0,0x10000000000000000),h(this._bytes,b(t),77),this},t.prototype.getSignature=function(){return this._bytes.slice(85,149)},t.prototype.setSignature=function(t){if(64!==t.length)throw new Error("invalid length");return h(this._bytes,t,85),this},t.prototype.sign=function(t){return this.setNonce((new Date).getTime()).setSignature(t.sign(this._bytes.slice(0,85)))},t.prototype.getPrefix=function(){return this.checkVersion([2,3]),v(_(this._bytes.slice(35,37)))},t.prototype.setPrefix=function(t){return this.checkVersion([2,3]),h(this._bytes,w(y(t)),35),this},t.prototype.getName=function(){if(this.checkVersion([2,3]),this._bytes[41]>35)throw new Error("invalid length");return ot(this._bytes.slice(42,42+this._bytes[41]))},t.prototype.setName=function(t){this.checkVersion([2,3]);var r=ht(t);if(r.length>35)throw new Error("name is too long");return h(this._bytes,o(36),41),h(this._bytes,r,42),this._bytes[41]=r.length,this},t.prototype.getProfitPercent=function(){return this.checkVersion([2,3]),_(this._bytes.slice(37,39))},t.prototype.setProfitPercent=function(t){return this.checkVersion([2,3]),ct(t,100,500),h(this._bytes,w(t),37),this},t.prototype.getFeePercent=function(){return this.checkVersion([2,3]),_(this._bytes.slice(39,41))},t.prototype.setFeePercent=function(t){return this.checkVersion([2,3]),ct(t,0,2e3),h(this._bytes,w(t),39),this},t.prototype.verify=function(){return this.getSender().getPublicKey().verifySignature(this.getSignature(),this._bytes.slice(0,85))},t.prototype.checkVersion=function(t){for(var r=0,e=t.length;r<e;r++)if(t[r]===this.getVersion())return;throw new Error("invalid version")},t.Genesis=0,t.Basic=1,t.CreateStructure=2,t.UpdateStructure=3,t.UpdateProfitAddress=4,t.UpdateFeeAddress=5,t.CreateTransitAddress=6,t.DeleteTransitAddress=7,t}();function o(t){for(var r=[],e=0;e<t;e++)r[e]=0;return r}function h(t,r,e,n){for(var i=e||0,o=n||r.length,h=0;h<o;h++)t[i+h]=r[h]}function f(t,r,e){for(var n=r||0,i=e||t.length,o=[],h=n;h<i;h++)o[o.length]=t[h];return o}function c(t,r){for(var e=f(t),n=0,i=r.length;n<i;n++)e[e.length]=r[n];return e}var s="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";var u="qpzry9x8gf2tvdw0s3jn54khce6mua7l";function a(t){for(var r,e=[996825010,642813549,513874426,1027748829,705979059],n=1,i=0,o=t.length;i<o;i++){r=n>>25,n=(33554431&n)<<5^t[i];for(var h=0;h<5;h++)n^=r>>h&1?e[h]:0}return n}function l(t){for(var r=o(2*t.length+1),e=0,n=t.length;e<n;e++){var i=t.charCodeAt(e);r[e]=i>>5,r[e+n+1]=31&i}return r}function g(t){for(var r=[],e=0,n=t.length;e<n;e++)r[r.length]=u.indexOf(t.charAt(e));return r}function v(t){if(ct(t,0,65535),0===t)return"genesis";if(32768==(32768&t))throw new Error("bech32: invalid version");var r=(31744&t)>>10,e=(992&t)>>5,n=31&t;return p([r,e,n]),String.fromCharCode(r+96,e+96,n+96)}function y(t){if("genesis"===t)return 0;!function(t,r){if("string"!=typeof t)throw new Error("invalid type");if(void 0!==r&&t.length!==r)throw new Error("invalid length")}(t,3);var r=t.charCodeAt(0)-96,e=t.charCodeAt(1)-96,n=t.charCodeAt(2)-96;return p([r,e,n]),(r<<10)+(e<<5)+n}function p(t){for(var r=0,e=t.length;r<e;r++)if(t[r]<1||t[r]>26)throw new Error("bech32: invalid prefix character")}function b(t){var r=16777216*(t>>>24)+(16777215&t),e=(t-r)/4294967296;return[e>>24&255,e>>16&255,e>>8&255,255&e,r>>24&255,r>>16&255,r>>8&255,255&r]}function d(t){return 4294967296*(16777216*t[0]+(t[1]<<16)+(t[2]<<8)+t[3])+(16777216*t[4]+(t[5]<<16)+(t[6]<<8)+t[7])}function w(t){return[t>>8&255,255&t]}function _(t){return t[0]<<8|t[1]}var A=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],E=[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],x=[61785,9906,39828,60374,45398,33411,5274,224,53552,61171,33010,6542,64743,22239,55772,9222],m=[54554,36645,11616,51542,42930,38181,51040,26924,56412,64982,57905,49316,21502,52590,14035,8553],P=[26200,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214],C=[237,211,245,92,26,99,18,88,214,156,247,162,222,249,222,20,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16];function V(t){var r=t.slice(0);!function(t,r,e){for(var n=e||0,i=0;i<r;i++)t[i]=n}(t,64),S(t,r)}function S(t,r){for(var e,n,i,o=63;o>=32;--o){for(e=0,n=o-32,i=o-12;n<i;++n)r[n]+=e-16*r[o]*C[n-(o-32)],e=Math.floor((r[n]+128)/256),r[n]-=256*e;r[n]+=e,r[o]=0}return function(t,r){var e,n=0;for(e=0;e<32;e++)r[e]+=n-(r[31]>>4)*C[e],n=r[e]>>8,r[e]&=255;for(e=0;e<32;e++)r[e]-=n*C[e];for(e=0;e<32;e++)r[e+1]+=r[e]>>8,t[e]=255&r[e];return t}(t,r)}function k(t,r,e){h(t[0],A),h(t[1],E),h(t[2],E),h(t[3],A);for(var n=255;n>=0;--n){var i=e[n/8|0]>>(7&n)&1;B(t,r,i),O(r,t),O(t,t),B(t,r,i)}}function B(t,r,e){for(var n=0;n<4;n++)M(t[n],r[n],e)}function O(t,r){var e=[],n=[],i=[],o=[],h=[],f=[],c=[],s=[],u=[];N(e,t[1],t[0]),N(u,r[1],r[0]),D(e,e,u),K(n,t[0],t[1]),K(u,r[0],r[1]),D(n,n,u),D(i,t[3],r[3]),D(i,i,x),D(o,t[2],r[2]),K(o,o,o),N(h,n,e),N(f,o,i),K(c,o,i),K(s,n,e),D(t[0],h,f),D(t[1],s,c),D(t[2],c,f),D(t[3],h,s)}function K(t,r,e){for(var n=0;n<16;n++)t[n]=r[n]+e[n]}function D(t,r,e){var n,i=o(31);for(n=0;n<16;n++)for(var f=0;f<16;f++)i[n+f]+=r[n]*e[f];for(n=0;n<15;n++)i[n]+=38*i[n+16];h(t,i,0,16),F(t),F(t)}function N(t,r,e){for(var n=0;n<16;n++)t[n]=r[n]-e[n]}function T(t,r){var e=[[],[],[],[]];h(e[0],m),h(e[1],P),h(e[2],E),D(e[3],m,P),k(t,e,r)}function F(t){for(var r,e=0;e<16;e++)t[e]+=65536,r=(t[e]-(65535&t[e]))/65536,t[(e+1)*(e<15?1:0)]+=r-1+37*(r-1)*(15===e?1:0),t[e]-=65536*r}function U(t,r){var e=[],n=[],i=[];!function(t,r){var e=[];h(e,r);for(var n=253;n>=0;n--)D(e,e,e),2!==n&&4!==n&&D(e,e,r);h(t,e)}(i,r[2]),D(e,r[0],i),D(n,r[1],i),R(t,n),t[31]^=L(e)<<7}function L(t){var r=[];return R(r,t),1&r[0]}function M(t,r,e){for(var n=~(e-1),i=0;i<16;i++){var o=n&(t[i]^r[i]);t[i]^=o,r[i]^=o}}function R(t,r){var e,n=[],i=r.slice(0);F(i),F(i),F(i);for(var o=0;o<2;o++){for(n[0]=i[0]-65517,e=1;e<15;e++)n[e]=i[e]-65535-(n[e-1]>>16&1),n[e-1]&=65535;n[15]=i[15]-32767-(n[14]>>16&1);var h=n[15]>>16&1;n[14]&=65535,M(i,n,1-h)}for(e=0;e<16;e++)t[2*e]=255&i[e],t[2*e+1]=i[e]>>8}var j=[30883,4953,19914,30187,55467,16705,2637,112,59544,30585,16505,36039,65139,11119,27886,20995],q=[41136,18958,6951,50414,58488,44335,6150,12099,55207,15867,153,11085,57099,20417,9344,11139];function z(t,r){for(var e=0,n=0;n<32;n++)e|=t[n]^r[n];return 1==(1&e-1>>>8)}function G(t,r){var e=[],n=[];return R(e,t),R(n,r),z(e,n)}var H="0123456789abcdef";var I=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298];function J(t){for(var r=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225],e=function(t){var r,e,n=[];for(r=0,e=t.length+8+(64-(t.length+8)%64);r<e;r++)n[r]=t[r]||0;n[t.length]=128,n[n.length-2]=8*t.length>>>8&255,n[n.length-1]=8*t.length&255;var i=[];for(r=0,e=n.length;r<e;r+=64){for(var o=[],h=0;h<64;h+=4){var f=r+h;o[o.length]=(n[f]<<24)+(n[++f]<<16)+(n[++f]<<8)+n[++f]}i[i.length]=o}return i}(t),n=0,i=e.length;n<i;n++){for(var o=e[n],h=16;h<64;h++){var f=W(o[h-15],7)^W(o[h-15],18)^o[h-15]>>>3,c=W(o[h-2],17)^W(o[h-2],19)^o[h-2]>>>10;o[h]=o[h-16]+f+o[h-7]+c}Q(r,o)}var s=[];for(h=0;h<8;h++)s[s.length]=r[h]>>>24&255,s[s.length]=r[h]>>>16&255,s[s.length]=r[h]>>>8&255,s[s.length]=255&r[h];return s}function Q(t,r){var e,n=[];for(e=0;e<8;e++)n[e]=t[e];for(e=0;e<64;e++){var i=W(n[4],6)^W(n[4],11)^W(n[4],25),o=n[4]&n[5]^~n[4]&n[6],h=n[7]+i+o+I[e]+r[e],f=(W(n[0],2)^W(n[0],13)^W(n[0],22))+(n[0]&n[1]^n[0]&n[2]^n[1]&n[2]);n[7]=n[6],n[6]=n[5],n[5]=n[4],n[4]=n[3]+h,n[3]=n[2],n[2]=n[1],n[1]=n[0],n[0]=h+f}for(e=0;e<8;e++)t[e]=t[e]+n[e]|0}function W(t,r){return t>>>r|t<<32-r}var X=[[1116352408,3609767458],[1899447441,602891725],[3049323471,3964484399],[3921009573,2173295548],[961987163,4081628472],[1508970993,3053834265],[2453635748,2937671579],[2870763221,3664609560],[3624381080,2734883394],[310598401,1164996542],[607225278,1323610764],[1426881987,3590304994],[1925078388,4068182383],[2162078206,991336113],[2614888103,633803317],[3248222580,3479774868],[3835390401,2666613458],[4022224774,944711139],[264347078,2341262773],[604807628,2007800933],[770255983,1495990901],[1249150122,1856431235],[1555081692,3175218132],[1996064986,2198950837],[2554220882,3999719339],[2821834349,766784016],[2952996808,2566594879],[3210313671,3203337956],[3336571891,1034457026],[3584528711,2466948901],[113926993,3758326383],[338241895,168717936],[666307205,1188179964],[773529912,1546045734],[1294757372,1522805485],[1396182291,2643833823],[1695183700,2343527390],[1986661051,1014477480],[2177026350,1206759142],[2456956037,344077627],[2730485921,1290863460],[2820302411,3158454273],[3259730800,3505952657],[3345764771,106217008],[3516065817,3606008344],[3600352804,1432725776],[4094571909,1467031594],[275423344,851169720],[430227734,3100823752],[506948616,1363258195],[659060556,3750685593],[883997877,3785050280],[958139571,3318307427],[1322822218,3812723403],[1537002063,2003034995],[1747873779,3602036899],[1955562222,1575990012],[2024104815,1125592928],[2227730452,2716904306],[2361852424,442776044],[2428436474,593698344],[2756734187,3733110249],[3204031479,2999351573],[3329325298,3815920427],[3391569614,3928383900],[3515267271,566280711],[3940187606,3454069534],[4118630271,4000239992],[116418474,1914138554],[174292421,2731055270],[289380356,3203993006],[460393269,320620315],[685471733,587496836],[852142971,1086792851],[1017036298,365543100],[1126000580,2618297676],[1288033470,3409855158],[1501505948,4234509866],[1607167915,987167468],[1816402316,1246189591]];function Y(t){for(var r=[[1779033703,4089235720],[3144134277,2227873595],[1013904242,4271175723],[2773480762,1595750129],[1359893119,2917565137],[2600822924,725511199],[528734635,4215389547],[1541459225,327033209]],e=Z(t),n=0,i=e.length;n<i;n++){for(var o=e[n],h=16;h<80;h++){var f=et(et(rt(o[h-15],1),rt(o[h-15],8)),tt(o[h-15],7)),c=et(et(rt(o[h-2],19),rt(o[h-2],61)),tt(o[h-2],6));o[h]=it(it(o[h-16],f),it(o[h-7],c))}$(r,o)}var s=[];for(h=0;h<8;h++)s[s.length]=r[h][0]>>>24&255,s[s.length]=r[h][0]>>>16&255,s[s.length]=r[h][0]>>>8&255,s[s.length]=255&r[h][0],s[s.length]=r[h][1]>>>24&255,s[s.length]=r[h][1]>>>16&255,s[s.length]=r[h][1]>>>8&255,s[s.length]=255&r[h][1];return s}function Z(t){var r,e,n=[];for(r=0,e=t.length+16+(128-(t.length+16)%128);r<e;r++)n[r]=t[r]||0;n[t.length]=128,n[n.length-2]=8*t.length>>>8&255,n[n.length-1]=8*t.length&255;var i=[];for(r=0,e=n.length;r<e;r+=128){for(var o=[],h=0;h<128;h+=8){var f=r+h;o[o.length]=[(n[f]<<24)+(n[++f]<<16)+(n[++f]<<8)+n[++f],(n[++f]<<24)+(n[++f]<<16)+(n[++f]<<8)+n[++f]]}i[i.length]=o}return i}function $(t,r){var e,n,i=[];for(e=0;e<8;e++)i[e]=[t[e][0],t[e][1]];for(e=0;e<80;e++){var o=et(et(rt(i[4],14),rt(i[4],18)),rt(i[4],41)),h=et(nt(i[4],i[5]),nt([~(n=i[4])[0],~n[1]],i[6])),f=it(it(it(i[7],o),it(h,X[e])),r[e]),c=it(et(et(rt(i[0],28),rt(i[0],34)),rt(i[0],39)),et(et(nt(i[0],i[1]),nt(i[0],i[2])),nt(i[1],i[2])));i[7]=i[6],i[6]=i[5],i[5]=i[4],i[4]=it(i[3],f),i[3]=i[2],i[2]=i[1],i[1]=i[0],i[0]=it(f,c)}for(e=0;e<8;e++)t[e]=it(t[e],i[e])}function tt(t,r){return[t[0]>>>r,t[1]>>>r|t[0]<<32-r]}function rt(t,r){return r<32?[t[0]>>>r|t[1]<<32-r,t[1]>>>r|t[0]<<32-r]:[t[1]>>>r-32|t[0]<<32-(r-32),t[0]>>>r-32|t[1]<<32-(r-32)]}function et(t,r){return[t[0]^r[0],t[1]^r[1]]}function nt(t,r){return[t[0]&r[0],t[1]&r[1]]}function it(t,r){var e=[0,0,0,0];return e[3]=(65535&t[1])+(65535&r[1]),e[2]=(t[1]>>>16)+(r[1]>>>16)+(e[3]>>>16),e[1]=(65535&t[0])+(65535&r[0])+(e[2]>>>16),e[0]=(t[0]>>>16)+(r[0]>>>16)+(e[1]>>>16),[((65535&e[0])<<16)+(65535&e[1]),((65535&e[2])<<16)+(65535&e[3])]}function ot(t){for(var r="",e=0;e<t.length;)if(t[e]<128)r+=String.fromCharCode(t[e++]);else if(t[e]>191&&t[e]<224)r+=String.fromCharCode((31&t[e++])<<6|63&t[e++]);else if(t[e]>223&&t[e]<240)r+=String.fromCharCode((15&t[e++])<<12|(63&t[e++])<<6|63&t[e++]);else{var n=((7&t[e++])<<18|(63&t[e++])<<12|(63&t[e++])<<6|63&t[e++])-65536;r+=String.fromCharCode(n>>10|55296,1023&n|56320)}return r}function ht(t){for(var r=[],e=0;e<t.length;){var n=t.charCodeAt(e++);n<128?r[r.length]=n:n<2048?(r[r.length]=192|n>>6,r[r.length]=128|63&n):n<55296||n>=57344?(r[r.length]=224|n>>12,r[r.length]=128|n>>6&63,r[r.length]=128|63&n):ft(r,65536+((1023&n)<<10)+(1023&t.charCodeAt(e++)))}return r}function ft(t,r){t[t.length]=240|r>>18,t[t.length]=128|r>>12&63,t[t.length]=128|r>>6&63,t[t.length]=128|63&r}function ct(t,r,e){if("number"!=typeof t)throw new Error("invalid type");if(Math.floor(t)!==t)throw new Error("invalid integer");if(t<r||t>e)throw new Error("invalid value")}return t.Address=r,t.PublicKey=e,t.SecretKey=n,t.Transaction=i,t.base64Decode=function(t){for(var r=function(t){if(t.length%4)throw new Error("base64: invalid length");for(var r=t.replace("=","").replace("=",""),e=0,n=r.length;e<n;e++)if(-1===s.indexOf(r.charAt(e)))throw new Error("base64: invalid character");return t.length/4*3-(t.length-r.length)}(t),e=t.replace("=","A").replace("=","A"),n=[],i=0,o=t.length;i<o;i+=4){var h=s.indexOf(e.charAt(i))<<18;h|=s.indexOf(e.charAt(i+1))<<12,h|=s.indexOf(e.charAt(i+2))<<6,h|=s.indexOf(e.charAt(i+3)),n[n.length]=h>>16&255,n[n.length]=h>>8&255,n[n.length]=255&h}return n.slice(0,r)},t.base64Encode=function(t){for(var r=t.slice(0),e="";r.length%3;)r[r.length]=0,e+="=";for(var n="",i=0,o=r.length;i<o;i+=3){var h=r[i]<<16|r[i+1]<<8|r[i+2];n+=s.charAt(h>>18&63)+s.charAt(h>>12&63),n+=s.charAt(h>>6&63)+s.charAt(63&h)}return n.slice(0,n.length-e.length)+e},t.hexDecode=function(t){var r=t.toLowerCase();!function(t){if(t.length%2)throw new Error("hex: invalid length");for(var r=0,e=t.length;r<e;r++)if(-1===H.indexOf(t.charAt(r)))throw new Error("hex: invalid character")}(r);for(var e=[],n=0,i=r.length;n<i;n+=2)e[e.length]=H.indexOf(r.charAt(n))<<4|H.indexOf(r.charAt(n+1));return e},t.hexEncode=function(t){for(var r="",e=0,n=t.length;e<n;e++)r+=H.charAt(t[e]>>4&15)+H.charAt(15&t[e]);return r},t.sha512PreProcess=Z,t.textDecode=ot,t.textEncode=ht,t}({});
diff --git a/node_modules/@umi-top/umi-core-js/lib/index.mjs b/node_modules/@umi-top/umi-core-js/lib/index.mjs
deleted file mode 100644
index 5439998..0000000
--- a/node_modules/@umi-top/umi-core-js/lib/index.mjs
+++ /dev/null
@@ -1,2095 +0,0 @@
-/**
- * @license
- * Copyright (c) 2020 UMI
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-/**
- * Класс для работы с адресами.
- * @class
- */
-class Address {
-  /**
-   * @example
-   * let address = new Address()
-   */
-  constructor () {
-    /**
-     * Адрес в бинарном виде, длина 34 байта.
-     * @type {number[]}
-     * @private
-     */
-    this._bytes = arrayNew(34)
-    this.setPrefix('umi')
-  }
-
-  /**
-   * Статический метод, создает объект из адреса в формате Bech32.
-   * @param {string} bech32 Адрес в формате Bech32, длина 62 или 65 символов.
-   * @returns {Address}
-   * @throws {Error}
-   * @example
-   * let address = Address.fromBech32('umi18d4z00xwk6jz6c4r4rgz5mcdwdjny9thrh3y8f36cpy2rz6emg5s6rxnf6')
-   */
-  static fromBech32 (bech32) {
-    const adr = new Address()
-    arraySet(adr._bytes, bech32Decode(bech32))
-    return adr
-  }
-
-  /**
-   * Статический метод, создает объект из бинарного представления.
-   * @param {ArrayLike<number>} bytes Адрес в бинарном виде, длина 34 байта.
-   * @returns {Address}
-   * @throws {Error}
-   * @example
-   * let address = Address.fromBytes(new Uint8Array(34))
-   */
-  static fromBytes (bytes) {
-    if (bytes.length !== 34) {
-      throw new Error('length must be 34 bytes')
-    }
-    const adr = new Address()
-    arraySet(adr._bytes, bytes)
-    return adr
-  }
-
-  /**
-   * Статический метод, создает объект из публичного или приватного ключа.
-   * @param {(PublicKey|SecretKey)} key Публичный или приватный ключ.
-   * @returns {Address}
-   * @example
-   * let secKey = SecretKey.fromSeed([])
-   * let address = Address.fromKey(secKey)
-   */
-  static fromKey (key) {
-    return new Address().setPublicKey(key.getPublicKey())
-  }
-
-  /**
-   * Адрес в формате Bech32, длина 62 или 65 символов.
-   * @returns {string}
-   * @example
-   * let bech32 = new Address().getBech32()
-   */
-  getBech32 () {
-    return bech32Encode(this._bytes)
-  }
-
-  /**
-   * Адрес в бинарном виде, длина 34 байта.
-   * @returns {number[]}
-   * @example
-   * let bytes = new Address().getBytes()
-   */
-  getBytes () {
-    return this._bytes.slice(0)
-  }
-
-  /**
-   * Префикс адреса, три символа латиницы в нижнем регистре.
-   * @returns {string}
-   * @throws {Error}
-   * @example
-   * let prefix = new Address().getPrefix()
-   */
-  getPrefix () {
-    return versionToPrefix(bytesToUint16(this._bytes.slice(0, 2)))
-  }
-
-  /**
-   * Устанавливает префикс адреса и возвращает this.
-   * @param {string} prefix Префикс адреса, три символа латиницы в нижнем регистре.
-   * @returns {Address}
-   * @throws {Error}
-   * @example
-   * let address = new Address().setPrefix('umi')
-   */
-  setPrefix (prefix) {
-    arraySet(this._bytes, uint16ToBytes(prefixToVersion(prefix)))
-    return this
-  }
-
-  /**
-   * Публичный ключ.
-   * @returns {PublicKey}
-   * @example
-   * let pubKey = new Address().getPublicKey()
-   */
-  getPublicKey () {
-    return new PublicKey(this._bytes.slice(2))
-  }
-
-  /**
-   * Устанавливает публичный ключ и возвращает this.
-   * @param {PublicKey} publicKey Публичный ключ.
-   * @returns {Address}
-   * @throws {Error}
-   * @example
-   * let pubKey = SecretKey.fromSeed([]).getPublicKey()
-   * let address = new Address().setPublicKey(pubKey)
-   */
-  setPublicKey (publicKey) {
-    arraySet(this._bytes, publicKey.getBytes(), 2)
-    return this
-  }
-}
-/**
- * Класс для работы с публичными ключами.
- * @class
- */
-class PublicKey {
-  /**
-   * @param {ArrayLike<number>} bytes Публичный ключ в формате libsodium, 32 байта.
-   * @throws {Error}
-   * @example
-   * let bytes = new Uint8Array(32)
-   * let pubKey = new PublicKey(bytes)
-   */
-  constructor (bytes) {
-    /**
-     * Публичный ключ в бинарном виде. В формате libsodium.
-     * @type {number[]}
-     * @private
-     */
-    this._bytes = []
-    if (bytes.length !== 32) {
-      throw new Error('invalid length')
-    }
-    arraySet(this._bytes, bytes)
-  }
-
-  /**
-   * Публичный ключ в формате libsodium, 32 байта.
-   * @returns {number[]}
-   * @example
-   * let bytes = new PublicKey(new Uint8Array(32)).getBytes()
-   */
-  getBytes () {
-    return this._bytes.slice(0)
-  }
-
-  /**
-   * Публичный ключ.
-   * @returns {PublicKey}
-   * @private
-   */
-  getPublicKey () {
-    return this
-  }
-
-  /**
-   * Проверяет цифровую подпись.
-   * @param {ArrayLike<number>} signature Подпись, 64 байта.
-   * @param {ArrayLike<number>} message Сообщение.
-   * @returns {boolean}
-   * @throws {Error}
-   * @example
-   * let pubKey = new PublicKey(new Uint8Array(32))
-   * let signature = new Uint8Array(64)
-   * let message = new TextEncoder().encode('Hello World')
-   * let isValid = pubKey.verifySignature(signature, message)
-   */
-  verifySignature (signature, message) {
-    if (signature.length !== 64) {
-      throw new Error('invalid length')
-    }
-    return verify(signature, message, this._bytes)
-  }
-}
-/**
- * Класс для работы с приватными ключами.
- * @class
- */
-class SecretKey {
-  /**
-   * @param {ArrayLike<number>} bytes Приватный ключ в бинарном виде.
-   * В формате libsodium, 64 байта.
-   * @throws {Error}
-   * @example
-   * let bytes = SecretKey.fromSeed(new Uint8Array(32)).getBytes()
-   * let secKey = new SecretKey(bytes)
-   */
-  constructor (bytes) {
-    /**
-     * Приватный ключ в бинарном виде. В формате libsodium.
-     * @type {number[]}
-     * @private
-     */
-    this._bytes = []
-    if (bytes.length !== 64) {
-      throw new Error('invalid length')
-    }
-    arraySet(this._bytes, bytes)
-  }
-
-  /**
-   * Статический метод, создающий приватный ключ из seed.\
-   * Libsodium принимает seed длиной 32 байта, поэтому если длина
-   * отличается, то берется sha256 хэш.
-   * @param {ArrayLike<number>} seed Массив байтов любой длины.
-   * @returns {SecretKey}
-   * @example
-   * let seed = new Uint8Array(32)
-   * let secKey = SecretKey.fromSeed(seed)
-   */
-  static fromSeed (seed) {
-    let entropy = seed
-    if (seed.length !== 32) {
-      entropy = sha256(entropy)
-    }
-    return new SecretKey(secretKeyFromSeed(entropy))
-  }
-
-  /**
-   * Приватный ключ в бинарном виде. В формате libsodium, 64 байта.
-   * @returns {number[]}
-   * @example
-   * let secKey = SecretKey.fromSeed(new Uint8Array(32))
-   * let bytes = secKey.getBytes()
-   */
-  getBytes () {
-    return this._bytes.slice(0)
-  }
-
-  /**
-   * Публичный ключ, соответствующий приватному ключу.
-   * @returns {PublicKey}
-   * @example
-   * let secKey = SecretKey.fromSeed(new Uint8Array(32))
-   * let pubKey = secKey.getPublicKey()
-   */
-  getPublicKey () {
-    return new PublicKey(this._bytes.slice(32, 64))
-  }
-
-  /**
-   * Создает цифровую подпись сообщения.
-   * @param {ArrayLike<number>} message Сообщение, которое необходимо подписать.
-   * @returns {number[]} Подпись длиной 64 байта.
-   * @example
-   * let secKey = SecretKey.fromSeed(new Uint8Array(32))
-   * let message = new TextEncoder().encode('Hello World')
-   * let signature = secKey.sign(message)
-   */
-  sign (message) {
-    return sign(message, this._bytes)
-  }
-}
-/**
- * Класс для работы с транзакциями.
- * @class
- */
-class Transaction {
-  /**
-   * @example
-   * let trx = new Transaction()
-   */
-  constructor () {
-    /**
-     * Транзакция в бинарном виде.
-     * @type {number[]}
-     * @private
-     */
-    this._bytes = arrayNew(150)
-    this.setVersion(Transaction.Basic)
-  }
-
-  /**
-   * Статический метод, создает объект из массива байтов.
-   * @param {ArrayLike<number>} bytes Транзакция в бинарном виде.
-   * @returns {Transaction}
-   * @throws {Error}
-   * @example
-   * let bytes = new Uint8Array(150)
-   * let trx = Transaction.fromBytes(bytes)
-   */
-  static fromBytes (bytes) {
-    if (bytes.length !== 150) {
-      throw new Error('invalid length')
-    }
-    const tx = new Transaction()
-    arraySet(tx._bytes, bytes)
-    return tx
-  }
-
-  /**
-   * Транзакция в бинарном виде, 150 байт.
-   * @returns {number[]}
-   * @example
-   * let bytes = new Transaction().getBytes()
-   */
-  getBytes () {
-    return this._bytes.slice(0)
-  }
-
-  /**
-   * Хэш (txid) транзакции.
-   * @returns {number[]}
-   * @example
-   * let hash = new Transaction().getHash()
-   */
-  getHash () {
-    return sha256(this._bytes)
-  }
-
-  /**
-   * Версия (тип) транзакции.
-   * @returns {number}
-   * @example
-   * let ver = new Transaction().getVersion()
-   */
-  getVersion () {
-    return this._bytes[0]
-  }
-
-  /**
-   * Устанавливает версию и возвращает this.
-   * @param {number} version Версия (тип) транзакции.
-   * @returns {Transaction}
-   * @throws {Error}
-   * @see Transaction.Genesis
-   * @see Transaction.Basic
-   * @see Transaction.CreateStructure
-   * @see Transaction.UpdateStructure
-   * @see Transaction.UpdateProfitAddress
-   * @see Transaction.UpdateFeeAddress
-   * @see Transaction.CreateTransitAddress
-   * @see Transaction.DeleteTransitAddress
-   */
-  setVersion (version) {
-    validateInt(version, 0, 7)
-    this._bytes[0] = version
-    return this
-  }
-
-  /**
-   * Отправитель.\
-   * Доступно для всех типов транзакций.
-   * @returns {Address}
-   * @example
-   * let sender = new Transaction().getSender()
-   */
-  getSender () {
-    return Address.fromBytes(this._bytes.slice(1, 35))
-  }
-
-  /**
-   * Устанавливает отправителя и возвращает this.
-   * @param {Address} address Адрес отправителя.
-   * @returns {Transaction}
-   * @throws {Error}
-   * @example
-   * let sender = new Address()
-   * let trx = new Transaction().setSender(sender)
-   */
-  setSender (address) {
-    arraySet(this._bytes, address.getBytes(), 1, 34)
-    return this
-  }
-
-  /**
-   * Получатель.\
-   * Недоступно для транзакций CreateStructure и UpdateStructure.
-   * @returns {Address}
-   * @example
-   * let recipient = new Transaction().getRecipient()
-   */
-  getRecipient () {
-    this.checkVersion([0, 1, 4, 5, 6, 7])
-    return Address.fromBytes(this._bytes.slice(35, 69))
-  }
-
-  /**
-   * Устанавливает получателя и возвращает this.\
-   * Недоступно для транзакций CreateStructure и UpdateStructure.
-   * @param {Address} address Адрес получателя.
-   * @returns {Transaction}
-   * @throws {Error}
-   * @example
-   * let recipient = new Address()
-   * let trx = new Transaction().setRecipient(recipient)
-   */
-  setRecipient (address) {
-    this.checkVersion([0, 1, 4, 5, 6, 7])
-    arraySet(this._bytes, address.getBytes(), 35)
-    return this
-  }
-
-  /**
-   * Сумма перевода в UMI-центах, цело число в промежутке от 1 до 18446744073709551615.\
-   * Доступно только для Genesis и Basic транзакций.
-   * @returns {number}
-   * @example
-   * let value = new Transaction().getValue()
-   */
-  getValue () {
-    this.checkVersion([0, 1])
-    return bytesToUint64(this._bytes.slice(69, 77))
-  }
-
-  /**
-   * Устанавливает сумму и возвращает this.\
-   * Принимает значения в промежутке от 1 до 18446744073709551615.\
-   * Доступно только для Genesis и Basic транзакций.
-   * @param {number} value Целое число от 1 до 18446744073709551615.
-   * @returns {Transaction}
-   * @throws {Error}
-   * @example
-   * let trx = new Transaction().setValue(42)
-   */
-  setValue (value) {
-    this.checkVersion([0, 1])
-    validateInt(value, 1, 18446744073709551615)
-    arraySet(this._bytes, uint64ToBytes(value), 69)
-    return this
-  }
-
-  /**
-   * Nonce, целое число в промежутке от 0 до 18446744073709551615.\
-   * Генерируется автоматически при вызове sign().
-   * @returns {number}
-   * @example
-   * let nonce = new Transaction().getNonce()
-   */
-  getNonce () {
-    return bytesToUint64(this._bytes.slice(77, 85))
-  }
-
-  /**
-   * Устанавливает nonce и возвращает this.
-   * @param {number} nonce Целое число в промежутке от 0 до 18446744073709551615.
-   * @returns {Transaction}
-   * @throws {Error}
-   * @example
-   * let nonce = Date.now()
-   * let trx = new Transaction().setNonce(nonce)
-   */
-  setNonce (nonce) {
-    validateInt(nonce, 0, 18446744073709551615)
-    arraySet(this._bytes, uint64ToBytes(nonce), 77)
-    return this
-  }
-
-  /**
-   * Цифровая подпись транзакции, длина 64 байта.
-   * @returns {number[]}
-   * @example
-   * let signature = new Transaction().getSignature()
-   */
-  getSignature () {
-    return this._bytes.slice(85, 149)
-  }
-
-  /**
-   * Устанавливает цифровую подпись и возвращает this.
-   * @param {ArrayLike<number>} signature Подпись, длина 64 байта.
-   * @returns {Transaction}
-   * @throws {Error}
-   * @example
-   * let signature = new Uint8Array(64)
-   * let trx = new Transaction().setSignature(signature)
-   */
-  setSignature (signature) {
-    if (signature.length !== 64) {
-      throw new Error('invalid length')
-    }
-    arraySet(this._bytes, signature, 85)
-    return this
-  }
-
-  /**
-   * Подписать транзакцию приватным ключом.
-   * @param {SecretKey} secretKey Приватный ключ.
-   * @returns {Transaction}
-   * @throws {Error}
-   * @example
-   * let secKey = SecretKey.fromSeed(new Uint8Array(32))
-   * let trx = new Transaction().sign(secKey)
-   */
-  sign (secretKey) {
-    return this.setNonce(new Date().getTime()).setSignature(secretKey.sign(this._bytes.slice(0, 85)))
-  }
-
-  /**
-   * Префикс адресов, принадлежащих структуре.\
-   * Доступно только для CreateStructure и UpdateStructure.
-   * @returns {string}
-   * @throws {Error}
-   * @example
-   * let trx = new Transaction().setVersion(Transaction.CreateStructure)
-   * let prefix = trx.getPrefix()
-   */
-  getPrefix () {
-    this.checkVersion([2, 3])
-    return versionToPrefix(bytesToUint16(this._bytes.slice(35, 37)))
-  }
-
-  /**
-   * Устанавливает префикс и возвращает this.\
-   * Доступно только для CreateStructure и UpdateStructure.
-   * @param {string} prefix Префикс адресов, принадлежащих структуре.
-   * @returns {Transaction}
-   * @throws {Error}
-   * @example
-   * let trx = new Transaction().setVersion(CreateStructure)
-   * trx.setPrefix('aaa')
-   */
-  setPrefix (prefix) {
-    this.checkVersion([2, 3])
-    arraySet(this._bytes, uint16ToBytes(prefixToVersion(prefix)), 35)
-    return this
-  }
-
-  /**
-   * Название структуры в кодировке UTF-8.\
-   * Доступно только для CreateStructure и UpdateStructure.
-   * @returns {string}
-   * @throws {Error}
-   * @example
-   * let trx = new Transaction().setVersion(Transaction.CreateStructure)
-   * let name = trx.getName()
-   */
-  getName () {
-    this.checkVersion([2, 3])
-    if (this._bytes[41] > 35) {
-      throw new Error('invalid length')
-    }
-    return textDecode(this._bytes.slice(42, 42 + this._bytes[41]))
-  }
-
-  /**
-   * Устанавливает название структуры и возвращает this.\
-   * Доступно только для CreateStructure и UpdateStructure.
-   * @param {string} name Название структуры в кодировке UTF-8.
-   * @returns {Transaction}
-   * @throws {Error}
-   * @example
-   * let trx = new Transaction().setVersion(Transaction.CreateStructure)
-   * trx.setName('Hello World')
-   */
-  setName (name) {
-    this.checkVersion([2, 3])
-    const bytes = textEncode(name)
-    if (bytes.length > 35) {
-      throw new Error('name is too long')
-    }
-    arraySet(this._bytes, arrayNew(36), 41)
-    arraySet(this._bytes, bytes, 42)
-    this._bytes[41] = bytes.length
-    return this
-  }
-
-  /**
-   * Профита в сотых долях процента с шагом в 0.01%.\
-   * Принимает значения от 100 до 500 (соответственно от 1% до 5%).\
-   * Доступно только для CreateStructure и UpdateStructure.
-   * @returns {number}
-   * @example
-   * let trx = new Transaction().setVersion(Transaction.CreateStructure)
-   * let profit = trx.getProfitPercent(100)
-   */
-  getProfitPercent () {
-    this.checkVersion([2, 3])
-    return bytesToUint16(this._bytes.slice(37, 39))
-  }
-
-  /**
-   * Устанавливает процент профита и возвращает this.\
-   * Доступно только для CreateStructure и UpdateStructure.
-   * @param {number} percent Профит в сотых долях процента с шагом в 0.01%.
-   * Принимает значения от 100 до 500 (соответственно от 1% до 5%).
-   * @returns {Transaction}
-   * @throws {Error}
-   * @example
-   * let trx = new Transaction().setVersion(Transaction.CreateStructure)
-   * trx.setProfitPercent(100)
-   */
-  setProfitPercent (percent) {
-    this.checkVersion([2, 3])
-    validateInt(percent, 100, 500)
-    arraySet(this._bytes, uint16ToBytes(percent), 37)
-    return this
-  }
-
-  /**
-   * Комиссия в сотых долях процента с шагом в 0.01%.\
-   * Принимает значения от 0 до 2000 (соответственно от 0% до 20%).\
-   * Доступно только для CreateStructure и UpdateStructure.
-   * @returns {number}
-   * @example
-   * let trx = new Transaction().setVersion(Transaction.CreateStructure)
-   * let fee = trx.getFeePercent()
-   */
-  getFeePercent () {
-    this.checkVersion([2, 3])
-    return bytesToUint16(this._bytes.slice(39, 41))
-  }
-
-  /**
-   * Устанавливает размер комиссии и возвращает this.\
-   * Доступно только для CreateStructure и UpdateStructure.
-   * @param {number} percent Комиссия в сотых долях процента с шагом в 0.01%. Принимает значения от 0 до 2000 (соответственно от 0% до 20%).
-   * @returns {Transaction}
-   * @throws {Error}
-   * @example
-   * let trx = new Transaction().setVersion(Transaction.CreateStructure)
-   * trx.setFeePercent(100)
-   */
-  setFeePercent (percent) {
-    this.checkVersion([2, 3])
-    validateInt(percent, 0, 2000)
-    arraySet(this._bytes, uint16ToBytes(percent), 39)
-    return this
-  }
-
-  /**
-   * Проверить транзакцию на соответствие формальным правилам.
-   * @returns {boolean}
-   * @throws {Error}
-   * @example
-   * let ver = new Transaction().verify()
-   */
-  verify () {
-    return this.getSender().getPublicKey().verifySignature(this.getSignature(), this._bytes.slice(0, 85))
-  }
-
-  /**
-   * @param {number[]} versions
-   * @throws {Error}
-   * @private
-   */
-  checkVersion (versions) {
-    for (let i = 0, l = versions.length; i < l; i++) {
-      if (versions[i] === this.getVersion()) {
-        return
-      }
-    }
-    throw new Error('invalid version')
-  }
-}
-/**
- * Genesis-транзакция.\
- * Может быть добавлена только в Genesis-блок.\
- * Адрес отправителя должен иметь префикс genesis, адрес получателя - umi.
- * @type {number}
- * @constant
- * @example
- * let secKey = SecretKey.fromSeed(new Uint8Array(32))
- * let sender = Address.fromKey(secKey).setPrefix('genesis')
- * let recipient = Address.fromKey(secKey).setPrefix('umi')
- * let tx = new Transaction()
- *   .setVersion(Transaction.Genesis)
- *   .setSender(sender)
- *   .setRecipient(recipient)
- *   .setValue(42)
- *   .sign(secKey)
- */
-Transaction.Genesis = 0
-/**
- * Стандартная транзакция. Перевод монет из одного кошелька в другой.
- * @type {number}
- * @constant
- * @example
- * let secKey = SecretKey.fromSeed(new Uint8Array(32))
- * let sender = Address.fromKey(secKey).setPrefix('umi')
- * let recipient = Address.fromKey(secKey).setPrefix('aaa')
- * let tx = new Transaction()
- *   .setVersion(Transaction.Basic)
- *   .setSender(sender)
- *   .setRecipient(recipient)
- *   .setValue(42)
- *   .sign(secKey)
- */
-Transaction.Basic = 1
-/**
- * Создание новой структуры.
- * @type {number}
- * @constant
- * @example
- * let secKey = SecretKey.fromSeed(new Uint8Array(32))
- * let sender = Address.fromKey(secKey).setPrefix('umi')
- * let tx = new Transaction()
- *   .setVersion(Transaction.CreateStructure)
- *   .setSender(sender)
- *   .setPrefix('aaa')
- *   .setName('My Struct 🙂')
- *   .setProfitPercent(100)
- *   .setFeePercent(0)
- *   .sign(secKey)
- */
-Transaction.CreateStructure = 2
-/**
- * Обновление настроек существующей структуры.
- * @type {number}
- * @constant
- * @example
- * let secKey = SecretKey.fromSeed(new Uint8Array(32))
- * let sender = Address.fromKey(secKey).setPrefix('umi')
- * let tx = new Transaction()
- *   .setVersion(Transaction.UpdateStructure)
- *   .setSender(sender)
- *   .setPrefix('aaa')
- *   .setName('My New Struct 😎')
- *   .setProfitPercent(500)
- *   .setFeePercent(2000)
- *   .sign(secKey)
- */
-Transaction.UpdateStructure = 3
-/**
- * Изменение адреса для начисления профита.
- * @type {number}
- * @constant
- * @example
- * let secKey = SecretKey.fromSeed(new Uint8Array(32))
- * let sender = Address.fromKey(secKey).setPrefix('umi')
- * let newPrf = Address.fromBech32('aaa18d4z00xwk6jz6c4r4rgz5mcdwdjny9thrh3y8f36cpy2rz6emg5svsuw66')
- * let tx = new Transaction()
- *   .setVersion(Transaction.UpdateProfitAddress)
- *   .setSender(sender)
- *   .setRecipient(newPrf)
- *   .sign(secKey)
- */
-Transaction.UpdateProfitAddress = 4
-/**
- * Изменение адреса на который переводится комиссия.
- * @type {number}
- * @constant
- * @example
- * let secKey = SecretKey.fromSeed(new Uint8Array(32))
- * let sender = Address.fromKey(secKey).setPrefix('umi')
- * let newFee = Address.fromBech32('aaa18d4z00xwk6jz6c4r4rgz5mcdwdjny9thrh3y8f36cpy2rz6emg5svsuw66')
- * let tx = new Transaction()
- *   .setVersion(Transaction.UpdateFeeAddress)
- *   .setSender(sender)
- *   .setRecipient(newFee)
- *   .sign(secKey)
- */
-Transaction.UpdateFeeAddress = 5
-/**
- * Активация транзитного адреса.
- * @type {number}
- * @constant
- * @example
- * let secKey = SecretKey.fromSeed(new Uint8Array(32))
- * let sender = Address.fromKey(secKey).setPrefix('umi')
- * let transit = Address.fromBech32('aaa18d4z00xwk6jz6c4r4rgz5mcdwdjny9thrh3y8f36cpy2rz6emg5svsuw66')
- * let tx = new Transaction()
- *   .setVersion(Transaction.CreateTransitAddress)
- *   .setSender(sender)
- *   .setRecipient(transit)
- *   .sign(secKey)
- */
-Transaction.CreateTransitAddress = 6
-/**
- * Деактивация транзитного адреса.
- * @type {number}
- * @constant
- * @example
- * let secKey = SecretKey.fromSeed(new Uint8Array(32))
- * let sender = Address.fromKey(secKey).setPrefix('umi')
- * let transit = Address.fromBech32('aaa18d4z00xwk6jz6c4r4rgz5mcdwdjny9thrh3y8f36cpy2rz6emg5svsuw66')
- * let tx = new Transaction()
- *   .setVersion(Transaction.DeleteTransitAddress)
- *   .setSender(sender)
- *   .setRecipient(transit)
- *   .sign(secKey)
- */
-Transaction.DeleteTransitAddress = 7
-/**
- * @param {number[]} array
- * @param {number} [length]
- * @param [value]
- * @private
- */
-function arrayFill (array, length, value) {
-  const v = value || 0
-  for (let i = 0; i < length; i++) {
-    array[i] = v
-  }
-}
-/**
- * @param {number} length
- * @returns {number[]}
- * @private
- */
-function arrayNew (length) {
-  const a = []
-  for (let i = 0; i < length; i++) {
-    a[i] = 0
-  }
-  return a
-}
-/**
- * @param {number[]} a
- * @param {ArrayLike<number>} b
- * @param {number} [offset]
- * @param {number} [length]
- * @private
- */
-function arraySet (a, b, offset, length) {
-  const o = offset || 0
-  const l = length || b.length
-  for (let i = 0; i < l; i++) {
-    a[o + i] = b[i]
-  }
-}
-/**
- * @param {ArrayLike<number>} a
- * @param {number} [begin]
- * @param {number} [end]
- * @returns {number[]}
- * @private
- */
-function arraySlice (a, begin, end) {
-  const b = begin || 0
-  const e = end || a.length
-  const r = []
-  for (let i = b; i < e; i++) {
-    r[r.length] = a[i]
-  }
-  return r
-}
-/**
- * @param {ArrayLike<number>} a
- * @param {number[]} b
- * @returns {number[]}
- * @private
- */
-function arrayConcat (a, b) {
-  const r = arraySlice(a)
-  for (let i = 0, l = b.length; i < l; i++) {
-    r[r.length] = b[i]
-  }
-  return r
-}
-const base64Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
-/**
- * Декодирует Base64 строку в массив байтов.
- * @param {string} base64 Строка в кодировке Base64.
- * @returns {number[]}
- * @throws {Error}
- */
-function base64Decode (base64) {
-  const len = checkBase64Alphabet(base64)
-  const b64 = base64.replace('=', 'A').replace('=', 'A')
-  const res = []
-  for (let i = 0, l = base64.length; i < l; i += 4) {
-    let x = (base64Alphabet.indexOf(b64.charAt(i)) << 18)
-    x |= (base64Alphabet.indexOf(b64.charAt(i + 1)) << 12)
-    x |= (base64Alphabet.indexOf(b64.charAt(i + 2)) << 6)
-    x |= base64Alphabet.indexOf(b64.charAt(i + 3))
-    res[res.length] = (x >> 16) & 0xff
-    res[res.length] = (x >> 8) & 0xff
-    res[res.length] = x & 0xff
-  }
-  return res.slice(0, len)
-}
-/**
- * Кодирует массив байтов в Base64 строку.
- * @param {number[]} bytes Массив байтов.
- * @returns {string}
- */
-function base64Encode (bytes) {
-  const b = bytes.slice(0)
-  let pad = ''
-  while (b.length % 3) {
-    b[b.length] = 0
-    pad += '='
-  }
-  let res = ''
-  for (let i = 0, l = b.length; i < l; i += 3) {
-    const x = (b[i] << 16) | (b[i + 1] << 8) | b[i + 2]
-    res += base64Alphabet.charAt((x >> 18) & 0x3f) + base64Alphabet.charAt((x >> 12) & 0x3f)
-    res += base64Alphabet.charAt((x >> 6) & 0x3f) + base64Alphabet.charAt(x & 0x3f)
-  }
-  return res.slice(0, res.length - pad.length) + pad
-}
-/**
- * @param {string} chars
- * @return number
- * @throws {Error}
- * @private
- */
-function checkBase64Alphabet (chars) {
-  if (chars.length % 4) {
-    throw new Error('base64: invalid length')
-  }
-  const charz = chars.replace('=', '').replace('=', '')
-  for (let i = 0, l = charz.length; i < l; i++) {
-    if (base64Alphabet.indexOf(charz.charAt(i)) === -1) {
-      throw new Error('base64: invalid character')
-    }
-  }
-  return (chars.length / 4 * 3) - (chars.length - charz.length)
-}
-const bech32Alphabet = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'
-/**
- * @param {number[]} bytes
- * @returns {string}
- * @private
- */
-function bech32Encode (bytes) {
-  const prefix = versionToPrefix((bytes[0] << 8) + bytes[1])
-  const data = convert8to5(bytes.slice(2))
-  const checksum = createChecksum(prefix, data)
-  return prefix + '1' + data + checksum
-}
-/**
- * @param {string} bech32
- * @returns {number[]}
- * @private
- */
-function bech32Decode (bech32) {
-  if (bech32.length !== 62 && bech32.length !== 66) {
-    throw new Error('bech32: invalid length')
-  }
-  const str = bech32.toLowerCase()
-  const sepPos = str.lastIndexOf('1')
-  if (sepPos === -1) {
-    throw new Error('bech32: missing separator')
-  }
-  const pfx = str.slice(0, sepPos)
-  const ver = prefixToVersion(pfx)
-  const data = str.slice(sepPos + 1)
-  checkAlphabet(data)
-  verifyChecksum(pfx, data)
-  return arrayConcat(uint16ToBytes(ver), convert5to8(data.slice(0, -6)))
-}
-/**
- * @param {string} data
- * @returns {number[]}
- * @private
- */
-function convert5to8 (data) {
-  let value = 0
-  let bits = 0
-  const bytes = strToBytes(data)
-  const result = []
-  for (let i = 0; i < bytes.length; i++) {
-    value = (value << 5) | bytes[i]
-    bits += 5
-    while (bits >= 8) {
-      bits -= 8
-      result[result.length] = (value >> bits) & 0xff
-    }
-  }
-  if ((bits >= 5) || (value << (8 - bits)) & 0xff) {
-    throw new Error('bech32: invalid data')
-  }
-  return result
-}
-/**
- * @param {number[]} data
- * @returns {string}
- * @private
- */
-function convert8to5 (data) {
-  let value = 0
-  let bits = 0
-  let result = ''
-  for (let i = 0; i < data.length; i++) {
-    value = (value << 8) | data[i]
-    bits += 8
-    while (bits >= 5) {
-      bits -= 5
-      result += bech32Alphabet.charAt((value >> bits) & 0x1f)
-    }
-  }
-  /* istanbul ignore else */
-  if (bits > 0) {
-    result += bech32Alphabet.charAt((value << (5 - bits)) & 0x1f)
-  }
-  return result
-}
-/**
- * @param {string} prefix
- * @param {string} data
- * @returns {string}
- * @private
- */
-function createChecksum (prefix, data) {
-  const bytes = strToBytes(data)
-  const pfx = prefixExpand(prefix)
-  const values = arrayNew(pfx.length + bytes.length + 6)
-  arraySet(values, pfx)
-  arraySet(values, bytes, pfx.length)
-  const poly = polyMod(values) ^ 1
-  let checksum = ''
-  for (let i = 0; i < 6; i++) {
-    checksum += bech32Alphabet.charAt((poly >> 5 * (5 - i)) & 31)
-  }
-  return checksum
-}
-/**
- * @param {number[]} values
- * @returns {number}
- * @private
- */
-function polyMod (values) {
-  const gen = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3]
-  let chk = 1
-  let top
-  for (let i = 0, l = values.length; i < l; i++) {
-    top = chk >> 25
-    chk = (chk & 0x1ffffff) << 5 ^ values[i]
-    for (let j = 0; j < 5; j++) {
-      chk ^= ((top >> j) & 1)
-        ? gen[j]
-        : 0
-    }
-  }
-  return chk
-}
-/**
- * @param {string} prefix
- * @returns {number[]}
- * @private
- */
-function prefixExpand (prefix) {
-  const res = arrayNew((prefix.length * 2) + 1)
-  for (let i = 0, l = prefix.length; i < l; i++) {
-    const ord = prefix.charCodeAt(i)
-    res[i] = ord >> 5
-    res[i + l + 1] = ord & 31
-  }
-  return res
-}
-/**
- * @param {string} str
- * @returns {number[]}
- * @private
- */
-function strToBytes (str) {
-  const bytes = []
-  for (let i = 0, l = str.length; i < l; i++) {
-    bytes[bytes.length] = bech32Alphabet.indexOf(str.charAt(i))
-  }
-  return bytes
-}
-/**
- * @param {string} prefix
- * @param {string} data
- * @private
- */
-function verifyChecksum (prefix, data) {
-  const pfx = prefixExpand(prefix)
-  const bytes = strToBytes(data)
-  const values = arrayNew(pfx.length + bytes.length)
-  arraySet(values, pfx)
-  arraySet(values, bytes, pfx.length)
-  const poly = polyMod(values)
-  if (poly !== 1) {
-    throw new Error('bech32: invalid checksum')
-  }
-}
-/**
- * @param {string} chars
- * @private
- */
-function checkAlphabet (chars) {
-  for (let i = 0, l = chars.length; i < l; i++) {
-    if (bech32Alphabet.indexOf(chars.charAt(i)) === -1) {
-      throw new Error('bech32: invalid character')
-    }
-  }
-}
-/**
- * Конвертер цифровой версии префикса в текстовое представление.
- * @param {number} version
- * @returns {string}
- * @throws {Error}
- * @private
- */
-function versionToPrefix (version) {
-  validateInt(version, 0, 65535)
-  if (version === 0) {
-    return 'genesis'
-  }
-  if ((version & 0x8000) === 0x8000) {
-    throw new Error('bech32: invalid version')
-  }
-  const a = (version & 0x7C00) >> 10
-  const b = (version & 0x03E0) >> 5
-  const c = (version & 0x001F)
-  checkPrefixChars([a, b, c])
-  return String.fromCharCode((a + 96), (b + 96), (c + 96))
-}
-/**
- * Конвертер текстовой версии префикса в числовое представление.
- * @param {string} prefix
- * @returns {number}
- * @throws {Error}
- * @private
- */
-function prefixToVersion (prefix) {
-  if (prefix === 'genesis') {
-    return 0
-  }
-  validateStr(prefix, 3)
-  const a = prefix.charCodeAt(0) - 96
-  const b = prefix.charCodeAt(1) - 96
-  const c = prefix.charCodeAt(2) - 96
-  checkPrefixChars([a, b, c])
-  return (a << 10) + (b << 5) + c
-}
-/**
- * @param {number[]} chars
- * @throws {Error}
- * @private
- */
-function checkPrefixChars (chars) {
-  for (let i = 0, l = chars.length; i < l; i++) {
-    if (chars[i] < 1 || chars[i] > 26) {
-      throw new Error('bech32: invalid prefix character')
-    }
-  }
-}
-/**
- * @param {number} value
- * @returns {number[]}
- * @private
- */
-function uint64ToBytes (value) {
-  const l = ((value >>> 24) * 16777216) + (value & 0x00ffffff)
-  const h = (value - l) / 4294967296
-  return [
-    ((h >> 24) & 0xff), ((h >> 16) & 0xff), ((h >> 8) & 0xff), (h & 0xff),
-    ((l >> 24) & 0xff), ((l >> 16) & 0xff), ((l >> 8) & 0xff), (l & 0xff)
-  ]
-}
-/**
- * @param {number[]} bytes
- * @returns {number}
- * @private
- */
-function bytesToUint64 (bytes) {
-  const h = (bytes[0] * 16777216) + (bytes[1] << 16) + (bytes[2] << 8) + bytes[3]
-  const l = (bytes[4] * 16777216) + (bytes[5] << 16) + (bytes[6] << 8) + bytes[7]
-  return (h * 4294967296) + l
-}
-/**
- * @param {number} value
- * @returns {number[]}
- * @private
- */
-function uint16ToBytes (value) {
-  return [((value >> 8) & 0xff), (value & 0xff)]
-}
-/**
- * @param {number[]} bytes
- * @returns {number}
- * @private
- */
-function bytesToUint16 (bytes) {
-  return (bytes[0] << 8) | bytes[1]
-}
-const gf0 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
-const gf1 = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
-const D2 = [
-  0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0,
-  0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406
-]
-const X = [
-  0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c,
-  0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169
-]
-const Y = [
-  0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666,
-  0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666
-]
-const L = [
-  0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2,
-  0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10
-]
-/**
- * @param {number[]} r
- * @private
- */
-function reduce (r) {
-  const x = r.slice(0)
-  arrayFill(r, 64)
-  modL(r, x)
-}
-/**
- * @param {number[]} r
- * @param {number[]} x
- * @returns {number[]}
- * @private
- */
-function modL (r, x) {
-  let carry
-  let j
-  let k
-  for (let i = 63; i >= 32; --i) {
-    carry = 0
-    for (j = i - 32, k = i - 12; j < k; ++j) {
-      x[j] += carry - 16 * x[i] * L[j - (i - 32)]
-      carry = Math.floor((x[j] + 128) / 256)
-      x[j] -= carry * 256
-    }
-    x[j] += carry
-    x[i] = 0
-  }
-  return modLSub(r, x)
-}
-/**
- * @param {number[]} r
- * @param {number[]} x
- * @returns {number[]}
- * @private
- */
-function modLSub (r, x) {
-  let carry = 0
-  let i
-  for (i = 0; i < 32; i++) {
-    x[i] += carry - (x[31] >> 4) * L[i]
-    carry = x[i] >> 8
-    x[i] &= 255
-  }
-  for (i = 0; i < 32; i++) {
-    x[i] -= carry * L[i]
-  }
-  for (i = 0; i < 32; i++) {
-    x[i + 1] += x[i] >> 8
-    r[i] = x[i] & 255
-  }
-  return r
-}
-/**
- * @param {number[][]} p
- * @param {number[][]} q
- * @param {number[]} s
- * @private
- */
-function scalarmult (p, q, s) {
-  arraySet(p[0], gf0)
-  arraySet(p[1], gf1)
-  arraySet(p[2], gf1)
-  arraySet(p[3], gf0)
-  for (let i = 255; i >= 0; --i) {
-    const b = (s[(i / 8) | 0] >> (i & 7)) & 1
-    cswap(p, q, b)
-    add(q, p)
-    add(p, p)
-    cswap(p, q, b)
-  }
-}
-/**
- * @param {number[][]} p
- * @param {number[][]} q
- * @param {number} b
- * @private
- */
-function cswap (p, q, b) {
-  for (let i = 0; i < 4; i++) {
-    sel25519(p[i], q[i], b)
-  }
-}
-/**
- * @param {number[][]} p
- * @param {number[][]} q
- * @private
- */
-function add (p, q) {
-  const a = []
-  const b = []
-  const c = []
-  const d = []
-  const e = []
-  const f = []
-  const g = []
-  const h = []
-  const t = []
-  fnZ(a, p[1], p[0])
-  fnZ(t, q[1], q[0])
-  fnM(a, a, t)
-  fnA(b, p[0], p[1])
-  fnA(t, q[0], q[1])
-  fnM(b, b, t)
-  fnM(c, p[3], q[3])
-  fnM(c, c, D2)
-  fnM(d, p[2], q[2])
-  fnA(d, d, d)
-  fnZ(e, b, a)
-  fnZ(f, d, c)
-  fnA(g, d, c)
-  fnA(h, b, a)
-  fnM(p[0], e, f)
-  fnM(p[1], h, g)
-  fnM(p[2], g, f)
-  fnM(p[3], e, h)
-}
-/**
- * @param {number[]} o
- * @param {number[]} a
- * @param {number[]} b
- * @private
- */
-function fnA (o, a, b) {
-  for (let i = 0; i < 16; i++) {
-    o[i] = a[i] + b[i]
-  }
-}
-/**
- * @param {number[]} o
- * @param {number[]} a
- * @param {number[]} b
- * @private
- */
-function fnM (o, a, b) {
-  const t = arrayNew(31)
-  let i
-  for (i = 0; i < 16; i++) {
-    for (let j = 0; j < 16; j++) {
-      t[i + j] += a[i] * b[j]
-    }
-  }
-  for (i = 0; i < 15; i++) {
-    t[i] += 38 * t[i + 16]
-  }
-  arraySet(o, t, 0, 16)
-  car25519(o)
-  car25519(o)
-}
-/**
- * @param {number[]} o
- * @param {number[]} a
- * @param {number[]} b
- * @private
- */
-function fnZ (o, a, b) {
-  for (let i = 0; i < 16; i++) {
-    o[i] = a[i] - b[i]
-  }
-}
-/**
- * @param {number[][]} p
- * @param {number[]} s
- * @private
- */
-function scalarbase (p, s) {
-  const q = [[], [], [], []]
-  arraySet(q[0], X)
-  arraySet(q[1], Y)
-  arraySet(q[2], gf1)
-  fnM(q[3], X, Y)
-  scalarmult(p, q, s)
-}
-/**
- * @param {number[]} o
- * @private
- */
-function car25519 (o) {
-  let c
-  for (let i = 0; i < 16; i++) {
-    o[i] += 65536
-    c = (o[i] - (o[i] & 0xffff)) / 65536
-    o[(i + 1) * (i < 15 ? 1 : 0)] += c - 1 + 37 * (c - 1) * (i === 15 ? 1 : 0)
-    o[i] -= c * 65536
-  }
-}
-/**
- * @param {number[]} r
- * @param {number[][]} p
- * @private
- */
-function pack (r, p) {
-  const tx = []
-  const ty = []
-  const zi = []
-  inv25519(zi, p[2])
-  fnM(tx, p[0], zi)
-  fnM(ty, p[1], zi)
-  pack25519(r, ty)
-  r[31] ^= par25519(tx) << 7
-}
-/**
- * @param {number[]} a
- * @returns {number}
- * @private
- */
-function par25519 (a) {
-  const d = []
-  pack25519(d, a)
-  return d[0] & 1
-}
-/**
- * @param {number[]} o
- * @param {number[]} i
- * @private
- */
-function inv25519 (o, i) {
-  const c = []
-  arraySet(c, i)
-  for (let a = 253; a >= 0; a--) {
-    fnM(c, c, c)
-    if (a !== 2 && a !== 4) {
-      fnM(c, c, i)
-    }
-  }
-  arraySet(o, c)
-}
-/**
- * @param {number[]} p
- * @param {number[]} q
- * @param {number} b
- * @private
- */
-function sel25519 (p, q, b) {
-  const c = ~(b - 1)
-  for (let i = 0; i < 16; i++) {
-    const t = c & (p[i] ^ q[i])
-    p[i] ^= t
-    q[i] ^= t
-  }
-}
-/**
- * @param {number[]} o
- * @param {number[]} n
- * @private
- */
-function pack25519 (o, n) {
-  const m = []
-  const t = n.slice(0)
-  car25519(t)
-  car25519(t)
-  car25519(t)
-  let i
-  for (let j = 0; j < 2; j++) {
-    m[0] = t[0] - 0xffed
-    for (i = 1; i < 15; i++) {
-      m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1)
-      m[i - 1] &= 0xffff
-    }
-    m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1)
-    const b = (m[15] >> 16) & 1
-    m[14] &= 0xffff
-    sel25519(t, m, 1 - b)
-  }
-  for (i = 0; i < 16; i++) {
-    o[2 * i] = t[i] & 0xff
-    o[2 * i + 1] = t[i] >> 8
-  }
-}
-const D = [
-  0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070,
-  0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203
-]
-const I = [
-  0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43,
-  0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83
-]
-/**
- * @param {ArrayLike<number>} seed
- * @returns {number[]}
- * @private
- */
-function secretKeyFromSeed (seed) {
-  const pk = []
-  const p = [[], [], [], []]
-  const d = sha512(seed)
-  d[0] &= 248
-  d[31] &= 127
-  d[31] |= 64
-  scalarbase(p, d)
-  pack(pk, p)
-  return arrayConcat(seed, pk)
-}
-/**
- * @param {ArrayLike<number>} message
- * @param {ArrayLike<number>} secretKey
- * @returns {number[]}
- * @private
- */
-function sign (message, secretKey) {
-  const d = sha512(arraySlice(secretKey, 0, 32))
-  d[0] &= 248
-  d[31] &= 127
-  d[31] |= 64
-  const sm = d.slice(0)
-  arraySet(sm, message, 64)
-  const r = sha512(sm.slice(32))
-  reduce(r)
-  const p = [[], [], [], []]
-  scalarbase(p, r)
-  pack(sm, p)
-  arraySet(sm, arraySlice(secretKey, 32), 32)
-  const h = sha512(sm)
-  reduce(h)
-  for (let i = 0; i < 32; i++) {
-    for (let j = 0; j < 32; j++) {
-      r[i + j] += h[i] * d[j]
-    }
-  }
-  return arrayConcat(sm.slice(0, 32), modL(sm.slice(32), r).slice(0, 32))
-}
-/**
- * @param {ArrayLike<number>} signature
- * @param {ArrayLike<number>} message
- * @param {ArrayLike<number>} pubKey
- * @returns {boolean}
- * @private
- */
-function verify (signature, message, pubKey) {
-  const sm = []
-  const t = []
-  const p = [[], [], [], []]
-  const q = [[], [], [], []]
-  /* istanbul ignore if */
-  if (!unpackneg(q, arraySlice(pubKey))) {
-    return false
-  }
-  arraySet(sm, signature, 0)
-  arraySet(sm, message, 64)
-  const m = sm.slice(0)
-  arraySet(m, pubKey, 32)
-  const h = sha512(m)
-  reduce(h)
-  scalarmult(p, q, h)
-  scalarbase(q, sm.slice(32))
-  add(p, q)
-  pack(t, p)
-  return cryptoVerify32(sm, t)
-}
-/**
- * @param {number[][]} r
- * @param {number[]} p
- * @returns {boolean}
- * @private
- */
-function unpackneg (r, p) {
-  const t = []
-  const chk = []
-  const num = []
-  const den = []
-  const den2 = []
-  const den4 = []
-  const den6 = []
-  arraySet(r[2], gf1)
-  unpack25519(r[1], p)
-  fnM(num, r[1], r[1])
-  fnM(den, num, D)
-  fnZ(num, num, r[2])
-  fnA(den, r[2], den)
-  fnM(den2, den, den)
-  fnM(den4, den2, den2)
-  fnM(den6, den4, den2)
-  fnM(t, den6, num)
-  fnM(t, t, den)
-  pow2523(t, t)
-  fnM(t, t, num)
-  fnM(t, t, den)
-  fnM(t, t, den)
-  fnM(r[0], t, den)
-  fnM(chk, r[0], r[0])
-  fnM(chk, chk, den)
-  if (!neq25519(chk, num)) {
-    fnM(r[0], r[0], I)
-  }
-  fnM(chk, r[0], r[0])
-  fnM(chk, chk, den)
-  /* istanbul ignore if */
-  if (!neq25519(chk, num)) {
-    return false
-  }
-  if (par25519(r[0]) === (p[31] >> 7)) {
-    fnZ(r[0], gf0, r[0])
-  }
-  fnM(r[3], r[0], r[1])
-  return true
-}
-/**
- * @param {number[]} x
- * @param {number[]} y
- * @returns {boolean}
- * @private
- */
-function cryptoVerify32 (x, y) {
-  let d = 0
-  for (let i = 0; i < 32; i++) {
-    d |= x[i] ^ y[i]
-  }
-  return (1 & ((d - 1) >>> 8)) === 1
-}
-/**
- * @param {number[]} o
- * @param {number[]} n
- * @private
- */
-function unpack25519 (o, n) {
-  for (let i = 0; i < 16; i++) {
-    o[i] = n[2 * i] + (n[2 * i + 1] << 8)
-  }
-  o[15] &= 0x7fff
-}
-/**
- * @param {number[]} o
- * @param {number[]} i
- * @private
- */
-function pow2523 (o, i) {
-  const c = []
-  let a
-  for (a = 0; a < 16; a++) {
-    c[a] = i[a]
-  }
-  for (a = 250; a >= 0; a--) {
-    fnM(c, c, c)
-    if (a !== 1) {
-      fnM(c, c, i)
-    }
-  }
-  for (a = 0; a < 16; a++) {
-    o[a] = c[a]
-  }
-}
-/**
- * @param {number[]} a
- * @param {number[]} b
- * @throws {boolean}
- * @private
- */
-function neq25519 (a, b) {
-  const c = []
-  const d = []
-  pack25519(c, a)
-  pack25519(d, b)
-  return cryptoVerify32(c, d)
-}
-const hexAlphabet = '0123456789abcdef'
-/**
- * Декодирует Base16 строку в массив байтов.
- * @param {string} hex Строка в кодировке Base16.
- * @returns {number[]}
- * @throws {Error}
- */
-function hexDecode (hex) {
-  const h = hex.toLowerCase()
-  checkHexAlphabet(h)
-  const res = []
-  for (let i = 0, l = h.length; i < l; i += 2) {
-    res[res.length] = (hexAlphabet.indexOf(h.charAt(i)) << 4) | hexAlphabet.indexOf(h.charAt(i + 1))
-  }
-  return res
-}
-/**
- * Кодирует массив байтов в Base16 строку.
- * @param {number[]} bytes Массив байтов.
- * @returns {string}
- */
-function hexEncode (bytes) {
-  let res = ''
-  for (let i = 0, l = bytes.length; i < l; i++) {
-    res += hexAlphabet.charAt((bytes[i] >> 4) & 0xf) + hexAlphabet.charAt(bytes[i] & 0xf)
-  }
-  return res
-}
-/**
- * @param {string} chars
- * @throws {Error}
- * @private
- */
-function checkHexAlphabet (chars) {
-  if (chars.length % 2) {
-    throw new Error('hex: invalid length')
-  }
-  for (let i = 0, l = chars.length; i < l; i++) {
-    if (hexAlphabet.indexOf(chars.charAt(i)) === -1) {
-      throw new Error('hex: invalid character')
-    }
-  }
-}
-const sha256K = [
-  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
-  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3, 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
-  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
-  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
-  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13, 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
-  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
-  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
-  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208, 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
-]
-/**
- * Безопасный алгоритм хеширования, SHA2-256.
- * @see https://en.wikipedia.org/wiki/SHA-2
- * @param {ArrayLike<number>} message message
- * @returns {number[]} hash
- * @private
- */
-function sha256 (message) {
-  const h = [0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19]
-  const chunks = sha256PreProcess(message)
-  for (let j = 0, l = chunks.length; j < l; j++) {
-    const w = chunks[j]
-    for (let i = 16; i < 64; i++) {
-      const s0 = rotr(w[i - 15], 7) ^ rotr(w[i - 15], 18) ^ (w[i - 15] >>> 3)
-      const s1 = rotr(w[i - 2], 17) ^ rotr(w[i - 2], 19) ^ (w[i - 2] >>> 10)
-      w[i] = w[i - 16] + s0 + w[i - 7] + s1
-    }
-    sha256Block(h, w)
-  }
-  const digest = []
-  for (let i = 0; i < 8; i++) {
-    digest[digest.length] = h[i] >>> 24 & 0xff
-    digest[digest.length] = h[i] >>> 16 & 0xff
-    digest[digest.length] = h[i] >>> 8 & 0xff
-    digest[digest.length] = h[i] & 0xff
-  }
-  return digest
-}
-/**
- * @param {ArrayLike<number>} message
- * @returns {number[][]}
- * @private
- */
-function sha256PreProcess (message) {
-  const bytez = []
-  let i
-  let l
-  for (i = 0, l = message.length + 8 + (64 - ((message.length + 8) % 64)); i < l; i++) {
-    bytez[i] = message[i] || 0
-  }
-  bytez[message.length] = 0x80
-  bytez[bytez.length - 2] = ((message.length * 8) >>> 8) & 0xff
-  bytez[bytez.length - 1] = (message.length * 8) & 0xff
-  const chunks = []
-  for (i = 0, l = bytez.length; i < l; i += 64) {
-    const chunk = []
-    for (let j = 0; j < 64; j += 4) {
-      let n = i + j
-      chunk[chunk.length] = (bytez[n] << 24) + (bytez[++n] << 16) + (bytez[++n] << 8) + bytez[++n]
-    }
-    chunks[chunks.length] = chunk
-  }
-  return chunks
-}
-/**
- * @param {number[]} h
- * @param {number[]} w
- * @private
- */
-function sha256Block (h, w) {
-  const a = []
-  let i
-  for (i = 0; i < 8; i++) {
-    a[i] = h[i]
-  }
-  for (i = 0; i < 64; i++) {
-    const S1 = rotr(a[4], 6) ^ rotr(a[4], 11) ^ rotr(a[4], 25)
-    const ch = (a[4] & a[5]) ^ ((~a[4]) & a[6])
-    const t1 = a[7] + S1 + ch + sha256K[i] + w[i]
-    const S0 = rotr(a[0], 2) ^ rotr(a[0], 13) ^ rotr(a[0], 22)
-    const ma = (a[0] & a[1]) ^ (a[0] & a[2]) ^ (a[1] & a[2])
-    const t2 = S0 + ma
-    a[7] = a[6]
-    a[6] = a[5]
-    a[5] = a[4]
-    a[4] = a[3] + t1
-    a[3] = a[2]
-    a[2] = a[1]
-    a[1] = a[0]
-    a[0] = t1 + t2
-  }
-  for (i = 0; i < 8; i++) {
-    h[i] = h[i] + a[i] | 0
-  }
-}
-/**
- * @param {number} n
- * @param {number} i
- * @returns {number}
- * @private
- */
-function rotr (n, i) {
-  return (n >>> i) | (n << (32 - i))
-}
-const sha512K = [
-  [0x428a2f98, 0xd728ae22], [0x71374491, 0x23ef65cd], [0xb5c0fbcf, 0xec4d3b2f], [0xe9b5dba5, 0x8189dbbc], [0x3956c25b, 0xf348b538],
-  [0x59f111f1, 0xb605d019], [0x923f82a4, 0xaf194f9b], [0xab1c5ed5, 0xda6d8118], [0xd807aa98, 0xa3030242], [0x12835b01, 0x45706fbe],
-  [0x243185be, 0x4ee4b28c], [0x550c7dc3, 0xd5ffb4e2], [0x72be5d74, 0xf27b896f], [0x80deb1fe, 0x3b1696b1], [0x9bdc06a7, 0x25c71235],
-  [0xc19bf174, 0xcf692694], [0xe49b69c1, 0x9ef14ad2], [0xefbe4786, 0x384f25e3], [0x0fc19dc6, 0x8b8cd5b5], [0x240ca1cc, 0x77ac9c65],
-  [0x2de92c6f, 0x592b0275], [0x4a7484aa, 0x6ea6e483], [0x5cb0a9dc, 0xbd41fbd4], [0x76f988da, 0x831153b5], [0x983e5152, 0xee66dfab],
-  [0xa831c66d, 0x2db43210], [0xb00327c8, 0x98fb213f], [0xbf597fc7, 0xbeef0ee4], [0xc6e00bf3, 0x3da88fc2], [0xd5a79147, 0x930aa725],
-  [0x06ca6351, 0xe003826f], [0x14292967, 0x0a0e6e70], [0x27b70a85, 0x46d22ffc], [0x2e1b2138, 0x5c26c926], [0x4d2c6dfc, 0x5ac42aed],
-  [0x53380d13, 0x9d95b3df], [0x650a7354, 0x8baf63de], [0x766a0abb, 0x3c77b2a8], [0x81c2c92e, 0x47edaee6], [0x92722c85, 0x1482353b],
-  [0xa2bfe8a1, 0x4cf10364], [0xa81a664b, 0xbc423001], [0xc24b8b70, 0xd0f89791], [0xc76c51a3, 0x0654be30], [0xd192e819, 0xd6ef5218],
-  [0xd6990624, 0x5565a910], [0xf40e3585, 0x5771202a], [0x106aa070, 0x32bbd1b8], [0x19a4c116, 0xb8d2d0c8], [0x1e376c08, 0x5141ab53],
-  [0x2748774c, 0xdf8eeb99], [0x34b0bcb5, 0xe19b48a8], [0x391c0cb3, 0xc5c95a63], [0x4ed8aa4a, 0xe3418acb], [0x5b9cca4f, 0x7763e373],
-  [0x682e6ff3, 0xd6b2b8a3], [0x748f82ee, 0x5defb2fc], [0x78a5636f, 0x43172f60], [0x84c87814, 0xa1f0ab72], [0x8cc70208, 0x1a6439ec],
-  [0x90befffa, 0x23631e28], [0xa4506ceb, 0xde82bde9], [0xbef9a3f7, 0xb2c67915], [0xc67178f2, 0xe372532b], [0xca273ece, 0xea26619c],
-  [0xd186b8c7, 0x21c0c207], [0xeada7dd6, 0xcde0eb1e], [0xf57d4f7f, 0xee6ed178], [0x06f067aa, 0x72176fba], [0x0a637dc5, 0xa2c898a6],
-  [0x113f9804, 0xbef90dae], [0x1b710b35, 0x131c471b], [0x28db77f5, 0x23047d84], [0x32caab7b, 0x40c72493], [0x3c9ebe0a, 0x15c9bebc],
-  [0x431d67c4, 0x9c100d4c], [0x4cc5d4be, 0xcb3e42b6], [0x597f299c, 0xfc657e2a], [0x5fcb6fab, 0x3ad6faec], [0x6c44198c, 0x4a475817]
-]
-/**
- * Безопасный алгоритм хеширования, SHA2-512.
- * @see https://en.wikipedia.org/wiki/SHA-2
- * @param {ArrayLike<number>} message message
- * @returns {number[]}
- * @private
- */
-function sha512 (message) {
-  const h = [
-    [0x6a09e667, 0xf3bcc908], [0xbb67ae85, 0x84caa73b], [0x3c6ef372, 0xfe94f82b], [0xa54ff53a, 0x5f1d36f1],
-    [0x510e527f, 0xade682d1], [0x9b05688c, 0x2b3e6c1f], [0x1f83d9ab, 0xfb41bd6b], [0x5be0cd19, 0x137e2179]
-  ]
-  const chunks = sha512PreProcess(message)
-  for (let j = 0, l = chunks.length; j < l; j++) {
-    const w = chunks[j]
-    for (let i = 16; i < 80; i++) {
-      const s0 = xor64(xor64(rotr64(w[i - 15], 1), rotr64(w[i - 15], 8)), shft64(w[i - 15], 7))
-      const s1 = xor64(xor64(rotr64(w[i - 2], 19), rotr64(w[i - 2], 61)), shft64(w[i - 2], 6))
-      w[i] = sum64(sum64(w[i - 16], s0), sum64(w[i - 7], s1))
-    }
-    sha512Block(h, w)
-  }
-  const digest = []
-  for (let i = 0; i < 8; i++) {
-    digest[digest.length] = h[i][0] >>> 24 & 0xff
-    digest[digest.length] = h[i][0] >>> 16 & 0xff
-    digest[digest.length] = h[i][0] >>> 8 & 0xff
-    digest[digest.length] = h[i][0] & 0xff
-    digest[digest.length] = h[i][1] >>> 24 & 0xff
-    digest[digest.length] = h[i][1] >>> 16 & 0xff
-    digest[digest.length] = h[i][1] >>> 8 & 0xff
-    digest[digest.length] = h[i][1] & 0xff
-  }
-  return digest
-}
-/**
- * @param {ArrayLike<number>} message
- * @returns {number[][][]}
- * @private
- */
-function sha512PreProcess (message) {
-  const bytes = []
-  let i
-  let l
-  for (i = 0, l = message.length + 16 + (128 - ((message.length + 16) % 128)); i < l; i++) {
-    bytes[i] = message[i] || 0
-  }
-  bytes[message.length] = 0x80
-  bytes[bytes.length - 2] = ((message.length * 8) >>> 8) & 0xff
-  bytes[bytes.length - 1] = (message.length * 8) & 0xff
-  const chunks = []
-  for (i = 0, l = bytes.length; i < l; i += 128) {
-    const chunk = []
-    for (let j = 0; j < 128; j += 8) {
-      let n = i + j
-      chunk[chunk.length] = [
-        (bytes[n] << 24) + (bytes[++n] << 16) + (bytes[++n] << 8) + bytes[++n],
-        (bytes[++n] << 24) + (bytes[++n] << 16) + (bytes[++n] << 8) + bytes[++n]
-      ]
-    }
-    chunks[chunks.length] = chunk
-  }
-  return chunks
-}
-/**
- * @param {number[][]} h
- * @param {number[][]} w
- * @returns {number[][]}
- * @private
- */
-function sha512Block (h, w) {
-  const a = []
-  let i
-  for (i = 0; i < 8; i++) {
-    a[i] = [h[i][0], h[i][1]]
-  }
-  for (i = 0; i < 80; i++) {
-    const S1 = xor64(xor64(rotr64(a[4], 14), rotr64(a[4], 18)), rotr64(a[4], 41))
-    const ch = xor64(and64(a[4], a[5]), and64(not64(a[4]), a[6]))
-    const t1 = sum64(sum64(sum64(a[7], S1), sum64(ch, sha512K[i])), w[i])
-    const S0 = xor64(xor64(rotr64(a[0], 28), rotr64(a[0], 34)), rotr64(a[0], 39))
-    const ma = xor64(xor64(and64(a[0], a[1]), and64(a[0], a[2])), and64(a[1], a[2]))
-    const t2 = sum64(S0, ma)
-    a[7] = a[6]
-    a[6] = a[5]
-    a[5] = a[4]
-    a[4] = sum64(a[3], t1)
-    a[3] = a[2]
-    a[2] = a[1]
-    a[1] = a[0]
-    a[0] = sum64(t1, t2)
-  }
-  for (i = 0; i < 8; i++) {
-    h[i] = sum64(h[i], a[i])
-  }
-}
-/**
- * @param {number[]} n
- * @param {number} i
- * @returns {number[]}
- * @private
- */
-function shft64 (n, i) {
-  return [(n[0] >>> i), (n[1] >>> i) | (n[0] << (32 - i))]
-}
-/**
- * @param {number[]} n
- * @param {number[]} i
- * @returns {number[]}
- * @private
- */
-function rotr64 (n, i) {
-  if (i < 32) {
-    return [n[0] >>> i | n[1] << (32 - i), n[1] >>> i | n[0] << (32 - i)]
-  }
-  return [
-    n[1] >>> (i - 32) | n[0] << (32 - (i - 32)),
-    n[0] >>> (i - 32) | n[1] << (32 - (i - 32))
-  ]
-}
-/**
- * @param {number[]} a
- * @param {number[]} b
- * @returns {number[]}
- * @private
- */
-function xor64 (a, b) {
-  return [(a[0] ^ b[0]), (a[1] ^ b[1])]
-}
-/**
- * @param {number[]} a
- * @param {number[]} b
- * @returns {number[]}
- * @private
- */
-function and64 (a, b) {
-  return [(a[0] & b[0]), (a[1] & b[1])]
-}
-/**
- * @param {number[]} n
- * @returns {number[]}
- * @private
- */
-function not64 (n) {
-  return [~n[0], ~n[1]]
-}
-/**
- * @param {number[]} a
- * @param {number[]} b
- * @returns {number[]}
- * @private
- */
-function sum64 (a, b) {
-  const x = [0, 0, 0, 0]
-  x[3] = (a[1] & 0xffff) + (b[1] & 0xffff)
-  x[2] = (a[1] >>> 16) + (b[1] >>> 16) + (x[3] >>> 16)
-  x[1] = (a[0] & 0xffff) + (b[0] & 0xffff) + (x[2] >>> 16)
-  x[0] = (a[0] >>> 16) + (b[0] >>> 16) + (x[1] >>> 16)
-  return [((x[0] & 0xffff) << 16) + (x[1] & 0xffff), ((x[2] & 0xffff) << 16) + (x[3] & 0xffff)]
-}
-/**
- * Декодирует массив байтов UTF-8 в строку в кодировке UTF-16.
- * @see https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder
- * @param {number[]} bytes Массив байтов UTF-8.
- * @returns {string}
- */
-function textDecode (bytes) {
-  let str = ''
-  let i = 0
-  while (i < bytes.length) {
-    if (bytes[i] < 0x80) {
-      str += String.fromCharCode(bytes[i++])
-    } else if ((bytes[i] > 0xBF) && (bytes[i] < 0xE0)) {
-      str += String.fromCharCode((bytes[i++] & 0x1F) << 6 | bytes[i++] & 0x3F)
-    } else if (bytes[i] > 0xDF && bytes[i] < 0xF0) {
-      str += String.fromCharCode(((bytes[i++] & 0x0F) << 12) | ((bytes[i++] & 0x3F) << 6) | (bytes[i++] & 0x3F))
-    } else {
-      const code = (((bytes[i++] & 0x07) << 18) | ((bytes[i++] & 0x3F) << 12) | ((bytes[i++] & 0x3F) << 6) | (bytes[i++] & 0x3F)) - 0x010000
-      str += String.fromCharCode(code >> 10 | 0xD800, code & 0x03FF | 0xDC00)
-    }
-  }
-  return str
-}
-/**
- * Кодирует UTF-16 строку в массив байтов UTF-8.
- * @see https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder
- * @param {string} text Текстовая строка в кодировке UTF-16.
- * @returns {number[]}
- */
-function textEncode (text) {
-  const b = []
-  let i = 0
-  while (i < text.length) {
-    const code = text.charCodeAt(i++)
-    if (code < 0x80) {
-      b[b.length] = code
-    } else if (code < 0x800) {
-      b[b.length] = 0xc0 | (code >> 6)
-      b[b.length] = 0x80 | (code & 0x3f)
-    } else if (code < 0xd800 || code >= 0xe000) {
-      b[b.length] = 0xe0 | (code >> 12)
-      b[b.length] = 0x80 | ((code >> 6) & 0x3f)
-      b[b.length] = 0x80 | (code & 0x3f)
-    } else {
-      encodeUtf8Mb4(b, 0x10000 + ((code & 0x3ff) << 10) + (text.charCodeAt(i++) & 0x3ff))
-    }
-  }
-  return b
-}
-/**
- * @param {number[]} b
- * @param {number} code
- * @private
- */
-function encodeUtf8Mb4 (b, code) {
-  b[b.length] = 0xf0 | (code >> 18)
-  b[b.length] = 0x80 | ((code >> 12) & 0x3f)
-  b[b.length] = 0x80 | ((code >> 6) & 0x3f)
-  b[b.length] = 0x80 | (code & 0x3f)
-}
-/**
- * @param arg
- * @param {number} min
- * @param {number} max
- * @throws {Error}
- * @private
- */
-function validateInt (arg, min, max) {
-  if (typeof arg !== 'number') {
-    throw new Error('invalid type')
-  }
-  if (Math.floor(arg) !== arg) {
-    throw new Error('invalid integer')
-  }
-  if (arg < min || arg > max) {
-    throw new Error('invalid value')
-  }
-}
-/**
- * @param arg
- * @param {number} [len]
- * @throws {Error}
- * @private
- */
-function validateStr (arg, len) {
-  if (typeof arg !== 'string') {
-    throw new Error('invalid type')
-  }
-  if (typeof len !== 'undefined' && arg.length !== len) {
-    throw new Error('invalid length')
-  }
-}
-
-export { Address, PublicKey, SecretKey, Transaction, base64Decode, base64Encode, hexDecode, hexEncode, sha512PreProcess, textDecode, textEncode }
